
夏炘航
gold15580
6.1 逻辑门的多层感知机实现
实验总用时：00:00:00
nav
第2关：使用多层感知机实现异或逻辑门
100
学习内容
参考答案
记录
评论
任务描述
相关知识
感知机的局限性
使用多层感知机实现异或逻辑门的原理
编程要求
测试说明
任务描述
本关任务：使用多层感知机实现异或逻辑门。

相关知识
为了完成本关任务，你需要掌握：

感知机的局限性；
使用感知机实现异或逻辑门的原理。
本实训内容可参考《深度学习入门——基于 Python 的理论与实现》一书中第 2.4、2.5 章节的内容。

感知机的局限性
感知机可以看作是在空间中寻找一条直线，从而把不同目标的数据点分割在直线的两侧。下图描述了或门在平面中的分布，其中三角形表示值为1，圆形表示值为0，可以看到可以用一条直线将这两种点区分开。



图1
图1 或门
但是对于异或门来说，其真值表如下：

x1	x2	y
0	0	0
0	1	1
1	0	1
1	1	0
用同样的方法，在平面上表示异或门可以发现，平面上的任意直线都不能把属于不同目标的数据点分割开来。这表明了感知机的一个局限性：感知机只对线性可分的数据集有效，而对于更加复杂的数据集是无法得到理想的解的。



图2
图2 异或门
使用多层感知机实现异或逻辑门的原理
既然我们无法直接用感知机对异或门进行表示，那么我们可以换个思路，对异或门进行变换。在数学上，异或门可以通过与、或和与非逻辑门进行表示：

x 
1
​
  xor x 
2
​
 =(x 
1
​
  and x 
2
​
 ) nand (x 
1
​
  or x 
2
​
 )

这启发我们，将输入分别经过一个与门和一个或门，然后再将二者的结果经过一个与非门，就可以得到异或门。而在上一关中我们知道，与门、或门和与非门都可以通过感知机实现，那么将对应的感知机堆叠在一起，就可以得到异或门了。



图3
图3 用与、或、与非表示异或门
至此，我们引入了多层感知机。顾名思义，多层感知机就是将感知机进行堆叠得到的一种模型。尽管感知机只能够处理线性可分的数据，但因为符号函数的引入，感知机的输入和输出之间并不是线性相关的。因此，通过对感知机进行堆叠，整个模型就拥有了处理非线性数据的能力。这就是激活函数的思想，这将在下一个实训中进行介绍。

编程要求
根据提示，在右侧编辑器中 Begin 和 End 之间补充代码，使用感知机实现异或逻辑门。实训已经提供了一组mlp_and、mlp_or和mlp_nand的实现，你需要利用它们实现mlp_xor。

测试说明
平台会对你编写的代码进行测试。你的程序不需要读入任何输入，测试程序会调用你实现的mlp_xor，对上述异或逻辑门中的全部输入值组合进行测试，并与正确的结果进行比较。

开始你的任务吧，祝你成功！

说点什么
resize-icon
12345678910111213141516171819202122
import numpy as np


def mlp_and(x1, x2):
    x = np.array([x1, x2]).astype(np.float32)
    weight = np.array([0.5, 0.5]).astype(np.float32)
    bias = -0.7
    y = np.dot(weight, x) + bias
    if y <= 0:
        return 0

测试结果
测试集1
本关最大执行时间：20秒
上一关
run
评测
