
夏炘航
gold15480
6.4 全连接层和激活函数的反向传播的实现
实验总用时：00:00:01
nav
第2关：实现常用激活函数的反向传播
100
学习内容
参考答案
记录
评论
任务描述
相关知识
常用激活函数的反向传播
常用激活函数反向传播的实现
编程要求
测试说明
任务描述
本关任务：实现常用激活函数的反向传播。

相关知识
为了完成本关任务，你需要掌握：常用激活函数的反向传播。

本实训内容可参考《深度学习入门——基于 Python 的理论与实现》一书中第5.5章节的内容。

常用激活函数的反向传播
在上一关中，我们学习了全连接层的反向传播。在这一关中，我们更进一步，学习常用激活函数的反向传播。跟之前的实训一样，我们主要关注 sigmoid 和 ReLU 这两个激活函数。

1. sigmoid激活函数

在之前的实训中，我们学习了 sigmoid 激活函数的前向传播：

y=sigmoid(x)=1/(1+e 
−x
 )

因为激活函数都是逐元素进行计算的，因此激活函数的反向传播只需要根据函数求导法则求解即可：

∂x
∂y
​
 =(1−y)y

对于 sigmoid 激活函数，可以得到：

∂x
∂l
​
 = 
∂y
∂l
​
 ⋅ 
∂x
∂y
​
 = 
∂y
∂l
​
 ⋅(1−y)y

2. ReLU激活函数

在之前的实训中，我们学习了 ReLU 激活函数的前向传播：

y=ReLU(x)=max(0,x)

可以看到，ReLU 激活函数存在不可导点x=0，不能直接求导。此时，我们在该点处使用 ReLU 的次梯度：

∂x
∂y
​
 (0)=0

关于次梯度的概念，这里不做深入的介绍，感兴趣的同学可以阅读相关书籍。在引入次梯度之后，ReLU 激活函数的梯度可以完整的表示为：

∂x
∂y
​
 ={ 
0,x≤0
1,x>0
​
 

再结合之前的反向传播公式，就可以得到 ReLU 激活函数的反向传播计算方法。

常用激活函数反向传播的实现
对于 sigmoid 激活函数，实训拓展了在之前的实训定义的Sigmoid类，实训已经给出了forward(x)的实现，并针对反向传播的需要对其进行了一定的修改。你需要实现该类的反向传播函数backward(dout)，dout是损失函数相对于 Sigmoid 输出的梯度，即之前公式中的 
∂y
∂l
​
 ，是一个形状与输入x相同的numpy.ndarray。前向传播的输出记录在了self.out中，以方便你进行反向传播的计算。backward(dout)函数需要返回输入x的梯度。

对于 ReLU 激活函数，实训拓展了在之前的实训定义的ReLU类，实训已经给出了forward(x)的实现，并针对反向传播的需要对其进行了一定的修改。你需要实现该类的反向传播函数backward(dout)，dout是损失函数相对于 Sigmoid 输出的梯度，即之前公式中的 
∂y
∂l
​
 ，是一个形状与输入x相同的numpy.ndarray。self.mask记录了前向传播时每个输入是否小于等于 0，以方便你进行方向传播的计算。backward(dout)函数需要返回输入x的梯度。

编程要求
根据提示，在右侧编辑器 Begin 和 End 之间补充代码，实现上述激活函数的反向传播。

测试说明
平台会对你编写的代码进行测试，测试方法为：平台会随机产生输入x和输出梯度dout，然后根据你的实现创建一个Sigmoid/ReLU类的实例，然后利用该实例先进行前向传播计算，再进行反向传播计算。你的答案将并与标准答案进行比较。因为浮点数的计算可能会有误差，因此只要你的答案与标准答案之间的误差不超过10 
−5
 即可。

样例输入：

# 对于sigmoid激活函数：
x:
[[-1, 0, 1]]
dout:
[[1, 2, 3]]
#对于ReLU激活函数：
x:
[[-1, 0, 1]]
dout:
[[1, 2, 3]]
则对应的梯度为：

# 对于sigmoid激活函数：
dx:
[[0.20, 0.50, 0.59]]
#对于ReLU激活函数：
dx:
[0, 2, 3]
上述结果有四舍五入的误差，你可以忽略。

开始你的任务吧，祝你成功！

说点什么
resize-icon
12345678910111213141516171819202122
import numpy as np


class Sigmoid:
    def __init__(self):
        self.out = None

    def forward(self, x):
        r'''
        Sigmoid激活函数的前向传播。

测试结果
测试集1
本关最大执行时间：20秒
上一关
run
评测
