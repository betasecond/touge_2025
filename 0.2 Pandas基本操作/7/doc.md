任务描述
相关知识
创建时间对象
创建时间戳
创建时间段
创建时间元素的 Series
创建时间索引
创建以时间为索引的 Series 对象
时间索引对象处理
查找
切片
移动
重采样
常用时间系列频率参数
编程要求
测试说明
任务描述
本关任务：编写一个能计算数组平均值和最大值的小程序。

相关知识
Pandas 是非常著名的开源数据处理库，我们可以通过它完成对数据集进行快速读取、转换、过滤、分析等一系列操作。同样，Pandas 已经被证明为是非常强大的用于处理时间序列数据的工具。本节将介绍所有 Pandas 在时间序列数据上的处理方法。

创建时间对象
在 Pandas 中关于时间序列的常见对象有 6 种，分别是 Timestamp（时间戳）、DatetimeIndex（时间戳索引）、Period（时间段）、PeriodIndex（时间段索引）、以时间为元素的 Series 和以及以时间索引的 DataFrame。

创建时间戳
Timestamp 时间戳表示时间轴上的某一点，以下不同代码都可以生成相同时间戳。

创建时间为 2018 年 10 月 1 日的时间戳。

pd.Timestamp(2018, 10, 1)
[输出]:
Timestamp('2018-10-01 00:00:00')
也可以使创建的时间精确到时分秒。

pd.Timestamp("2018-10-1 10:00:1")
from datetime import datetime
pd.Timestamp(datetime(2018, 10, 1))
[输出]:
Timestamp('2018-10-01 00:00:00')
创建时间段
Period 时间段表示时间轴上的某一区间，以下代码都可以生成相同时间段。

# `Period()` 函数后面通常有两个参数，第二个 `freq` 参数决定时间段的分割长度。
pd.Period('2018-10')
[输出]:Period('2018-10', 'M')
# 创建频率为日的时间段。
pd.Period('2018-10', freq='D')
[输出]:Period('2018-10-01', 'D')
创建时间元素的 Series
Pandas 中常用 to_datetime() 函数可以创建以时间为元素的 Series。

创建一个 Series，以三个时间的字符串作为元素。

df = ['2018-08-01', '2018-09-01', '2018-10-01']
pd.to_datetime(df)
可以使用多种方法创建时间元素的 Series。

# 方法一：
df = pd.Series(['Sep 30, 2018', '2018-10-1', None])
pd.to_datetime(df)
# 方法二：
df = pd.DataFrame({'year': [2017, 2018],
'month': [9, 10],
'day': [30, 1],
'hour': [23, 0]})
pd.to_datetime(df)
创建时间索引
要生成带有时间戳的索引，可以使用 DatetimeIndex() 构造函数，并传入列表或 Series 对象：

dates = ['2018-08-01', '2018-09-01', '2018-10-01']
index = pd.DatetimeIndex(dates)
[输出]:
DatetimeIndex(['2018-08-01', '2018-09-01', '2018-10-01'], dtype='datetime64[ns]', freq=None)
实际运用中我们经常需要大量的的时间戳的索引。可以使用 date_range() 和 bdate_range() 来批量创建相同时间间隔的时间戳索引。

创建以 2018 年 9 月 30 日为开始的 150 条时间索引，相邻索引间隔时间长度为一个月。

index = pd.date_range('2018-9-30', periods=150, freq='M')
[输出]:
DatetimeIndex(['2018-09-30', '2018-10-31', '2018-11-30', '2018-12-31',
'2019-01-31', '2019-02-28', '2019-03-31', '2019-04-30',
'2019-05-31', '2019-06-30',
...
'2030-05-31', '2030-06-30', '2030-07-31', '2030-08-31',
'2030-09-30', '2030-10-31', '2030-11-30', '2030-12-31',
'2031-01-31', '2031-02-28'],
dtype='datetime64[ns]', length=150, freq='M')
创建以 2018 年 10 月 1 日为开始的 111 条时间索引，相邻索引间隔时间长度为一个工作日。

index = pd.bdate_range('2018-10-1', periods=111)
[输出]:
DatetimeIndex(['2018-10-01', '2018-10-02', '2018-10-03', '2018-10-04',
'2018-10-05', '2018-10-08', '2018-10-09', '2018-10-10',
'2018-10-11', '2018-10-12',
...
'2019-02-19', '2019-02-20', '2019-02-21', '2019-02-22',
'2019-02-25', '2019-02-26', '2019-02-27', '2019-02-28',
'2019-03-01', '2019-03-04'],
dtype='datetime64[ns]', length=111, freq='B')
在 date_range() 和 bdate_range() 中可以巧妙使用 start，end， periods，freq 等参数的各种组合轻松批量创建时间索引。

在 2017 年 10 月 1 日到 2018 年 10 月 1 日间，每隔一周创建一条索引。

start = datetime(2017, 10, 1)
end = datetime(2018, 10, 1)
rng = pd.date_range(start, end, freq='W')
从 2018 年 10 月 1 日向前每隔一个工作日创建一条索引，共 150 条。

pd.bdate_range(end=end, periods=150)
同理，时间段也能作为索引使用，需要用到 period_range()。

从 2018 年 9 月 30 日向后创建 666 条索引，相邻索引间隔时间长度为一天。

pi = pd.period_range('2018-9-30', periods=666)
创建以时间为索引的 Series 对象
以时间为索引的 Series 对象指的是在该 Series 中，元素的索引不再是 1、2、3、4、5……这样的序号，而是有序的日期和时间。

import numpy as np
dates = [pd.Timestamp('2018-08-01'), pd.Timestamp('2018-09-01'),
pd.Timestamp('2018-10-01')]  # 创建三个时间元素。
ts = pd.Series(np.random.randn(3), dates)   # 创建索引值为随机数的 Series 对象。
[输出]:
2018-08-01    0.057921
2018-09-01   -0.592673
2018-10-01    0.025957
dtype: float64
同样，时间段也能作为索引。

periods = [pd.Period('2018-08'), pd.Period('2018-09'), pd.Period('2018-10')]
ts = pd.Series(np.random.randn(3), periods)
我们可以批量创建索引后再创建以时间为索引的 Series 对象。创建索引值为随机数的 Series 对象，长度与 rng 长度相同。

ts = pd.Series(np.random.randn(len(rng)), index=rng)
2017-10-01   -0.382455
2017-10-08    2.626258
...
2018-09-16    0.018793
2018-09-23   -1.299962
2018-09-30    0.327516
Freq: W-SUN, dtype: float64
时间段也能作为索引创建 DataFrame 对象。在 2017 年第一季度和 2018 年第四季度之间每隔一个季度创建一条索引。

prng = pd.period_range('2017Q1', '2018Q4', freq='Q-NOV')
# 行索引为时间段索引，列索引为 A。
ps = pd.DataFrame(np.random.rand(len(prng)), columns=['A'], index=prng)
时间索引对象处理
以时间戳为索引的 Series、DataFrame 对象具有与普通列表近乎相同的操作，且更具智能化。

查找
# 简单查找。
ts
# 查找前 10 条索引记录。
ts[:10]
# 每隔 1 条记录查找 1 条索引记录。
ts[::2]
# 查找第 0、2、6 条索引记录。
ts[[0, 2, 6]]
基于时间索引的精确查找。查找索引为 2018 年 9 月 30 日的值。

ts["09/30/2018"]
ts[datetime(2018, 9, 30)]
# 基于索引的范围查找。查找索引时间在 2017 年内的所有记录。
ts["2017"]
#查找索引时间在 2018 年 9 月内的所有记录。
ts["2018-9"]
# 以时间段为索引的 `DataFrame` 对象的查找规则与以时间戳的相同。
以时间段为索引的 DataFrame 对象的查找规则与以时间戳的相同。

# 2018 年的第一个季度规定为 2017 年的 12 月初到 2018 年的 2 月末。
# 查找 2017 年内的所有季度的记录。
ps["2017"]
# 查找 2017 年 12 月 31 日前的所有季度的记录。
ps[:datetime(2017, 12, 31)]
# 查找 2018 年 6 月内的所有季度的记录。
ps["2018-06"]
切片
使用 truncate() 切下 2017 年 11 月 26 日与 2018 年 4 月 29 日间的记录。

ts.truncate(before='11/26/2017', after='4/29/2018')
移动
将时间索引 Series 中的值向后和向前移动。其方法是 shift()。

ts = ts[:5]  # 取前 5 条数据方便观察。
ts
将元素列向下移动一条。

ts.shift(1)
除了元素可以被移动，索引本身也能被移动，需要加上 freq 参数。将索引列向上移动一条：

ts.shift(1, freq='W')
重采样
重采样可以通俗得理解为改变时间索引的个数，通过增大或减小相邻索引的时间间隔以达到减小或增加索引数量的效果，在 Pandas 中使用 resample() 函数。

下采样：增大时间间隔，减少记录的数量。创建从 2018 年 10 月 1 日开始的日间隔索引的 Series 。

rng = pd.date_range('10/1/2018', periods=10, freq='D')
ts = pd.Series(np.random.randint(0, 50, len(rng)), index=rng)
ts
原先索引的日间隔被扩大为周间隔，并以周末为索引采样点，采样点的索引值为所有未被索引值的和。

ts.resample('W').sum()
同样也能使采样点的索引值为所有未被索引值的平均值。

ts.resample('W').mean()
使用 ohlc() 函数对所用未被采样值进行统计。

ts.resample('W').ohlc()
上采样：减小时间间隔频率，增加记录的数量。

原来间隔为日的索引列，间隔被缩小成 12 小时，增加采样点的值为空值。

ts.resample('12H').asfreq()
ffill() 函数可以将新增的索引值以相邻的前一条索引值进行填充。

ts.resample('12H').ffill()
常用时间系列频率参数
参数名	说明
B	工作日频率
C	定制工作日频率
D	日历日频率
W	每周频率
M	月结束频率
SM	半月结束频率(15 个月和月末)
BM	业务月末频率
CBM	定制业务月末频率
MS	月起始频率
sMs	半月起始频率(第 1 和 15)
BMS	业务月开始频率
CBMS	定制商业月份开始频率
Q	四分频结束频率
BQ	业务四分之一频率
QS	四分频启动频率
BQS	业务季开始频率
A	年结束频率
BA	业务年结束频率
AS	年起始频率
BAS	业务年开始频率
BH	工作时间频率
H	每小时频率
T, min	分钟频率
S	次频
L, ms	毫秒
U, uS	微秒
N	纳秒
编程要求
根据提示，在右侧编辑器的Begin-End部分补充代码，使用Pandas时间序列方法完成相关的操作。

任务要求：

创建以 2021 年1 月1 日为开始的 12 条时间索引，相邻索引间隔时间长度为一个月。

在 2021 年 1 月 1 日到 2021 年 3 月 1 日间，每隔一周创建一条索引。

给定以时间为索引的 Series 对象，查找索引时间在 2021 年 1 月内的所有记录。

测试说明
平台会对你编写的代码进行测试：

测试输入：
预期输出：

任务1输出：
DatetimeIndex(['2021-01-31', '2021-02-28', '2021-03-31', '2021-04-30',
'2021-05-31', '2021-06-30', '2021-07-31', '2021-08-31',
'2021-09-30', '2021-10-31', '2021-11-30', '2021-12-31'],
dtype='datetime64[ns]', freq='M')
任务2输出：
DatetimeIndex(['2021-01-03', '2021-01-10', '2021-01-17', '2021-01-24',
'2021-01-31', '2021-02-07', '2021-02-14', '2021-02-21',
'2021-02-28'],
dtype='datetime64[ns]', freq='W-SUN')
任务3输出：
2021-01-03    0
2021-01-10    1
2021-01-17    2
2021-01-24    3
2021-01-31    4
Freq: W-SUN, dtype: int64
开始你的任务吧，祝你成功！

